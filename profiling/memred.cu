#include <cstdio>
#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

#include "../utilities/cudaGraphUtilities.hpp"
#include "../utilities/cudaUtilities.hpp"
#include "memred.hpp"

namespace memopt {

/**
 * Constructor for MemRedAnalysisParser
 * 
 * Parses the MemRed analysis output file to extract information about
 * kernel functions and their memory access patterns. The file follows a
 * specific format generated by the MemRed tool.
 */
MemRedAnalysisParser::MemRedAnalysisParser() {
  // Open the analysis file generated by MemRed
  std::ifstream in(ANALYSIS_FILE.data());
  std::string ignore; // Used to skip tokens we don't need to process
  
  // Process each kernel in the file
  while (in) {
    KernelInfo kernelInfo;

    // Read the function name
    // Format example: "Function void CalcMinDtOneBlock<1024>(double*, double*, double*, double*, int) (@_Z17CalcMinDtOneBlockILi1024EEvPdS0_S0_S0_i):"
    // We need to extract the mangled name after the '@' symbol
    char ch;
    // Find the '@' character that precedes the mangled function name
    do {
      in.read(&ch, 1);
    } while (in && ch != '@');
    if (!in) break; // End of file or error condition

    // Read the mangled function name
    std::string funcName;
    in >> funcName;
    // Remove trailing "): " from the function name
    funcName.erase(funcName.size() - 2);
    kernelInfo.funcName = funcName;

    // Read the function's overall memory effect classification
    // Format example: "Memory Effect: ArgMemOnly"
    // Options include: "ArgMemOnly" (only accesses memory through arguments)
    // or "AnyMem" (may access any memory, including global variables)
    std::string memoryEffect;
    in >> ignore >> ignore >> memoryEffect; // Skip "Memory" and "Effect:" tokens
    kernelInfo.memoryEffect = memoryEffect;

    // Read each argument's memory access pattern
    // Format example: "Arg #0: Effect: ReadOnly Capture: No"
    while (1) {
      std::string argumentKeyword;
      in >> argumentKeyword;
      
      // Check if we've reached the next function or end of file
      if (argumentKeyword == "Function" || !in)
        break;
        
      // Ensure we're reading an argument entry
      if (argumentKeyword != "Arg") {
        abort(); // File format error
      }

      // Skip the space and # character
      in.read(&ch, 1);  // ' '
      in.read(&ch, 1);  // '#'

      // Read the argument index
      size_t argumentIndex;
      in >> argumentIndex;

      // Read the memory access effect for this pointer argument
      std::string ptrArgEffect;
      
      // Skip ": Effect: " and read the effect type (ReadOnly/WriteOnly/ReadWrite)
      // Then skip "Capture: No" which isn't relevant for our analysis
      in >> ignore >> ignore >> ptrArgEffect >> ignore >> ignore;

      // Store the argument index and its memory effect
      kernelInfo.ptrArgInfos.push_back({argumentIndex, ptrArgEffect});
    }

    // Add this kernel's info to our map using the function name as key
    funcNameToKernelInfoMap[funcName] = kernelInfo;
  }
}

/**
 * Extracts data dependencies for a specific kernel node in a CUDA graph
 * 
 * Uses the kernel's memory access information to determine which pointers
 * are used as inputs (read from) and which are outputs (written to).
 * 
 * @param kernelNode The CUDA graph node representing a kernel execution
 * @return DataDependency object containing sets of input and output pointers
 */
OptimizationInput::TaskGroup::DataDependency MemRedAnalysisParser::getKernelDataDependency(cudaGraphNode_t kernelNode) {
  // Get the kernel node parameters (function, arguments, etc.)
  CUDA_KERNEL_NODE_PARAMS nodeParams;
  getKernelNodeParams(kernelNode, nodeParams);

  // Get the function name for this kernel
  const char *funcName;
  checkCudaErrors(cuFuncGetName(&funcName, nodeParams.func));
  std::string s(funcName);
  
  // Check if we have analysis data for this kernel
  if (this->funcNameToKernelInfoMap.count(s) == 0) {
    std::cerr << "[MemRed]: Could not find kernel " << s << std::endl;
    abort();
  }

  // Get the kernel info from our map
  auto kernelInfo = this->funcNameToKernelInfoMap[s];
  
  // If the kernel has "AnyMem" effect, we can't accurately determine dependencies
  // because it might access memory not passed as arguments
  if (kernelInfo.memoryEffect == "AnyMem") {
    std::cerr << "[MemRed]: The memory effect of kernel " << s << "is AnyMem. ";
    std::cerr << "Please annotate the data dependency of the task containing the kernel explicitly." << std::endl;
    abort();
  }

  // Create a data dependency object to hold our results
  OptimizationInput::TaskGroup::DataDependency dataDependency;
  
  // Process each pointer argument and its memory effect
  for (const auto &[index, effect] : kernelInfo.ptrArgInfos) {
    if (effect == "None") {
      // Skip arguments that don't affect memory
      continue;
    } else if (effect == "ReadOnly") {
      // For read-only arguments, add to inputs set
      dataDependency.inputs.insert(*static_cast<void **>(nodeParams.kernelParams[index]));
    } else if (effect == "WriteOnly") {
      // For write-only arguments, add to outputs set
      dataDependency.outputs.insert(*static_cast<void **>(nodeParams.kernelParams[index]));
    } else {
      // For read-write arguments, add to both inputs and outputs sets
      dataDependency.inputs.insert(*static_cast<void **>(nodeParams.kernelParams[index]));
      dataDependency.outputs.insert(*static_cast<void **>(nodeParams.kernelParams[index]));
    }
  }

  return dataDependency;
}

}  // namespace memopt
